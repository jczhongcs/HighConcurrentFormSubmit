# HighConcurrentFormSubmit
黄智颖毕设进度
一、整体思路
大致分为几部走:1.确定系统设计2.实现分布式session（单点登录解决）3.带高并发的主功能解决方案。
1.系统设计部分：
我这次打算做一个高并发的选课系统，使用前端框架thymeleaf和原本的html加一些css做点缀即可，thymeleaf主要应用到页面缓存，实际应用很少，基本都是用html来实现。
2.数据库设计部分：
我建立了用户表，课程表，选课表，学生选课对应的order表，以及选课后详情表供查看信息。
      3.   应用的高并发解决思路的中间件以及技术和之后打算使用到的技术：
	   已经应用到的技术：redis的注入，mysql的注入，rabbitmq消息队列中间件。
	    期望后用到的：nginx（用于负载均衡），lvs（同上）

     二、已完成的部分思路:
	1. 分布式session:
	这里我采用标识token来进行问题的解决

	每次登录利用uuid生成一个tok，并将其封装到客户端的cookie里，这样下次登录可以直接在cookie里取来对应登录状态，同时：

将其带前缀封装到redis中去：

此时会再设置一个限时的tok，保证在时间内登录有效，同时该tok每次进行新操作也会刷新有效时间（此处设置24小时有效时间）:


2.高并发的主功能实现:
	①此处首先是第一步，建立好对应的用户和课程对应的表，作为唯一索引（以免出现在高并发选课场景下重复选课的情况）:
	
紧接着是对redis的操作，这里使用了redis作为预减课程做的缓存来做异步选课的操作:
首先第一步，将原有的选课表中存留课程数加载到redis中作为键值对来判定。


②接着是对用户来进行选课的操作,首先预减，紧接着是判重（此处其实也可以利用sql的唯一索引，但是这里其实并不影响性能所以也做了）:

这里建立一个专门的msg类来进行封装课程id以及用户:

(消息队列略，没有什么技术含量，纯就是声明一个存活的消息队列然后传递值进行一下字符串跟bean的转换）
在receiver这个类中最后进行选课的操作（异步）:



③这里真正的选课操作:（做transactional以便失败了直接回滚。）

先减（reduce不做transactional）后建立对应order：


建立好了order直接在redis设置一个key标识唯一对应uid以及课程id的对应标志（后续就不用搜sql了直接redis来进行取值）。
在reduce那里会回一个值判定是否有余量这样直接给redis设一个选完的标识：

最后再返回结果:

3.基本的jmeter进行压力测试，此处生成5000个用户，每个用户每秒进行10次选课操作，模拟5000个并发：


此处专门对选课接口进行测试：
测试用例:
id: 1  course_name: 理想国导读 course_remain(课程余量) 50 (其余略。)
结果:

吐吞量接近3k8.
验证数据一致性：


c_order数量:

mysql中的情况:


无误。
后续打算引用nginx等技术，现在crud以及前端需要完善:


三月初本周的优化部分:页面缓存内容:
此处我用了thymeleaf的模板:

此处的页面缓存同样是交给redis来做:
在getSelresult方法中进行优化:

同样的，利用IWebContext类进行web页面的封装，封装成string类型最后在进行设置，这里同样的设置了一个刷新期限，暂定45秒，优化了过多访问导致对服务器请求的压力，但是也有缺点，就是会造成已经选完课了而45秒前的用户可能看不到选完的结果，而要等待刷新后才会知道。
完成了部分查询功能:

后续优化增加拦截器等功能来进行判定。
